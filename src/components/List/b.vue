<template>
  <div>
    <pre>
      参考地址：https://juejin.cn/post/7016593221815910408
      参考地址：https://juejin.cn/post/6992843117963509791
      重点有浏览器缓存、Http2.0、Https通信过程、TCP与UDP、DNS解析、CDN缓存等。
      HTTP1, HTTP2, HTTPS、常见的http状态码；
      浏览从输入网址到回车发生了什么；
      前端安全（CSRF、XSS）
      前端跨域、浏览器缓存、cookie, session, token, localstorage, sessionstorage；
      TCP连接(三次握手, 四次挥手)
    </pre>
    <pre>
      <h5>http 和 https基本概念</h5>
      htpp：超文本协议； https：安全的信息通道，确保数据的安全传输，安全的协议；
      <h5>http和https的区别缺点和优点</h5>
      http: 是超文本传输协议，明文传送；https：ssl加密传输，保护传送数据:
      http端口号：80；  https端口号：443
      https需要额外的费用；
      <h5>HTTP 请求跨域问题</h5>
      跨域原理：
        为什么为造成http请求跨域，是因为浏览器的同源策略，同源策略就是地址有一个不同即为跨域（域名，端口，协议）
        同源策略是浏览器对js实施的安全限制；
      解决方案：
        最初做项目的时候用的jsonp，后台通过学习和了解发现proxy代理配合起来比较方便，后台就引导服务器后端做一下服务器配置；
        在开发中使用proxy，在服务器中使用nginx代理，还有h5的新特性 window.postMessage()

        1. jsonp: 只支持get请求，因为script标签的src只能使用get请求，后端返回指定格式的数据
          步骤：
          创建一个script标签，
          在script标签src上设置请求接口地址：script.src = 'http://localhost:3000/?callback=getData';
          如果需要参数，必须自定义一个函数，来接受后端的参数；
        2. window：全局变量
        3. CORS：跨资源共享，服务器设置 Access-Control-Allow-Origin HTTP响应头之后，浏览器允许跨域；
        4. proxy代理：
        5. window.postMessage()
      <h5>Cookie、sessionStorage、localStorage 的区别</h5>
       1. cookie存储比较小大约4k，session和local比较大
       2. cookie数据在设置的过期时间之前一直有效，session在浏览器关系数据丢失，local数据永久存储，除非手动删除
       3. cookie数据会自动传输到服务器，session和local保存在本地；
      <h5>简述从输入URL到页面加载的全过程</h5>
       1. 在浏览器中输入url；
       2. 浏览器向Dns服务器发起请求，解析url对应的ip地址；
       3. 服务器响应请求并返回结果：服务器对浏览器做出的请求做出回应，返回对应的html文件给浏览器；
       4. 浏览器解析服务器返回的文件，并渲染到页面；
      <h5>浏览器的缓存机制分为： 强制缓存 && 协商缓存</h5>
      
      浏览器缓存机制 ==》 HTTP缓存机制
      机制的根据  ==》就是HTTP的报文缓存标识

      1. HTTP报文分两种：
        1.HTTP请求（request）报文：格式 =》 请求行-http头（）-请求报文主体（只有post报文主体）
        2.HTTP响应（response）报文： 状态行 – HTTP头(通用信息头，响应头，实体头) – 响应报文主体
      2. 为什么需要浏览器缓存：
       通过HTT P协议，客户端和服务器建起联系，需要消耗时间，大的响应需要客户端和服务器多次通信才能返回完整的结果，这就增加了浏览器处理内容的时间；
       利用浏览器缓存机制可以优化性能，获取浏览器存储的数据；
      3. 缓存过程的分析
       浏览器和服务器通信的方式为应答模式，第一次发送请求，服务器接受请求并返回数据和响应报文 http标识符，浏览器会根据豹纹的标识符来决定是否缓存到浏览器缓存中；
       如果标识是，会将缓存标识和结果存入浏览器缓存中；
      
       浏览器每次请求都会先浏览器缓存查找结果和缓存标识
       浏览器每次拿到请求的结果和标识符都将存入浏览器缓存中
      4. 是否需要向浏览器发起http缓存过程分为强制缓存和协商缓存
        
      强制缓存（浏览器发起http请求向浏览器缓存查询结果，并根据查询结果中的情况来决定是否使用该结果的过程就是强制缓存 ***********）
        强制缓存分三种情况向浏览器缓存查询的时候：
        >1 不存在缓存结果和缓存标识，强制缓存失败，向服务器发送请求；（强制缓存失败，直接向服务器请求）
        >2 存在缓存结果和缓存标识，但是结果已失效，带着缓存标识向服务器发送请求，强制缓存失败，则使用协商缓存（强制缓存失败，使用协商缓存）
        >3 存在缓存结果和缓存标识，结果未失效， 强制缓存生效，直接赶回结果 （强制缓存生效）
      强制缓存的缓存规则是什么？
        在浏览器向服务器发送请求的时候，服务器接受请求并响应，服务器会将缓存规则放入响应报文的http头中和结果一起返回给浏览器，
        浏览器会根据服务器规则字段来决定是否存入浏览器缓存中；
        控制缓存的规则字段分别是expires和cache-control，如果两个字段同时存在，cache-control优先级更高一些；
      expires：
        缓存的到期时间，如果客户端在缓存的到期时间之内请求，则使用的是浏览器缓存结果；
        缺点：expires是绝对是时间，如果客户端和服务器端地区不同，则容易出现时间的不准确性；强制缓存失效，这样设置的参数则毫无意义；
      cache-control：
        应用的是相对时间，比如max-age = 6000 时间为秒；缓存内容将在xxx秒后失效
        public：所有的都将被缓存
        private：所有的内容只有客户端可以缓存（默认值）
        no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定
        no-store：所有内容都不被缓存，记不使用强制缓存也不使用协商缓存；

      浏览器的缓存放在了哪里，判断强制缓存是否生效？
        缓存存在的位置 from memory cache， dish cache

        from memory cache： 内存缓存（特点快速读取和实效性）
           快速读取：
           实效性：关闭进程，则会清空
        dish cache：硬盘缓存（速度比内存缓存慢）

      协商缓存（就是强制缓存失败，浏览器带着浏览器缓存标识想服务器发送请求，由服务器根据标识来决定是否使用缓存的过程）
      分为以下两种情况：
      >1 协商缓存生效 返回304状态
       浏览器发送http请求 --> 强制缓存失败，只返回缓存的标识 --> 浏览器携带者标识再次向服务器发送请求 --> 浏览器根据缓存标识判断资源是否更新
        --> 304，资源没有更新， --> 取浏览器缓存取缓存结果  --> 返回给浏览器

      >2 协商缓存失败 返回200状态和请求结果
      浏览器发送http请求 --> 强制缓存失败，只返回缓存的标识 --> 浏览器携带者标识再次向服务器发送请求 --> 浏览器根据缓存标识判断资源是否更新
        --> 服务器查看资源更新了 重新返回资源结果和状态200，返回给浏览器 -->  将返回的资源结果和缓存标识符存入浏览器缓存

      协商缓存的缓存规则字段分别是两对 Last-Modified / If-Modified-Since，Etag / If-None-Match（优先级高）

      总结：
      若强制缓存(Expires和Cache-Control,Cache-Control优先级高于Expires)生效则直接使用缓存
      若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match，其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高)，协商缓存由服务器决定是否使用缓存
      若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回304，继续使用缓存

      <h5>浏览器</h5>
      <h5>从输入url到页面加载的全过程（浏览器工作原理）</h5>
      浏览器主要功能就是想服务器发送http请求，获取数据渲染到页面，然后浏览器解析后端发送过来的数据过程
      》在页面中输入url
      》DNS解析域名，浏览器向DNS服务器发起请求，解析url中域名对应的ip地址；
      》发起http请求，浏览器想服务器发送http请求，获取数据
      》服务器接到响应并返回结果，服务器接到请求并响应，并把对应的html文件发送给浏览器
      》浏览器渲染，浏览器解析数据并渲染到页面，浏览器接收到数据包渲染的过程如下：
       构建dom树（dom tree）：是由dom元素和节点组成，dom树的根是document树
       构建css规则树：生成css规则树
       构建render树：web浏览器将dom和css结合在一起，并构建出渲染树
       布局（layout）：计算每个节点在屏幕的位置；
       绘制（painting）：使用UI绘制每个节点；
      》js引擎解析过程
       创建window对象：window对象就是全局执行环境，当页面创建时就产生了，所有的全局变量和全局函数都属于window对象的属性和方法，当关闭页面和网页
                     全局执行的环境即为销毁；
       预编译：在预编译的时候，浏览器会查找全局变量声明，把它作为window的属性加入到window对象中，并赋值为undefined；
               寻找全局函数声明，把它做为window的方法加入到window对象中，并将函数体赋值给她；
       解释执行：

      <h5>DNS域名解析过程</h5>
        参考地址：https://juejin.cn/post/7005468491067162655
        我们都知道当浏览器通过域名发送一个网络请求的时候，会有DNS服务器将域名解析成ip地址，以便于正确的ip地址发送请求
        具体流程如下
       1. 浏览器会会检查浏览器缓存中有没有域名对应的IP地址，这个缓存是有过期时间的；
       2. 如果浏览器缓存中没有在检查操作系统中的hosts文件（本地文件）；
       3. 如果本地的hosts文件也没有配置域名对应的ip地址，我们就会想DNS服务器发送请求来解析域名对应的ip地址；
       4. 服务器查询域名和ip地址对应的映射表
       5. 把解析的结果返回给用户，将返回值存于缓存中；
      <h5>CDN缓存</h5>
        CDN缓存是将源站的资源缓存到CDN服务器，当用户访问资源的时候从最近的CDN服务器获取资源而不是从根源上获取资源，
        好处解决了源服务站压力，从而提升了用户访问速度提升了性能
        CDN原理：
        当用户访问一个网站时，如果没有 CDN，过程是这样的
        1.浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。
        2.本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到网站服务器的 IP 地址。
        3.本地 DNS 将 IP 地址发回给浏览器，浏览器向网站服务器 IP 地址发出请求并得到资源。

        当用户访问一个网站时，如果有CDN，过程是这样的
        1.浏览器要将域名解析为 IP 地址，所以需要向本地 DNS 发出请求。
        2.本地 DNS 依次向根服务器、顶级域名服务器、权限服务器发出请求，得到全局负载均衡系统（GSLB）的 IP 地址。
        3.本地 DNS 再向 GSLB 发出请求，GSLB 的主要功能是根据本地 DNS 的 IP 地址判断用户的位置，筛选出距离用户较近的本地负载均衡系统（SLB），并将该 SLB 的 IP 地址作为结果返回给本地 DNS。
        4.本地 DNS 将 SLB 的 IP 地址发回给浏览器，浏览器向 SLB 发出请求。
        5.SLB 根据浏览器请求的资源和地址，选出最优的缓存服务器发回给浏览器。
        6.浏览器再根据 SLB 发回的地址重定向到缓存服务器。
        7.如果缓存服务器有浏览器需要的资源，就将资源发回给浏览器。如果没有，就向源服务器请求资源，再发给浏览器并缓存在本地

      <h5>浏览器重绘与重排的区别？</h5>
      重排：当dom元素发生了变化，需要重新布局元素节点位置，叫做重排，元素的位置和尺寸大小发生变化会影响dom重新绘制（影响比较大一些）
      重绘：绘制dom外观，没有改变布局，重新绘制元素外观的过程叫做重绘（比如颜色，字体大小）
      <h5>如何触发重绘或者重排</h5>
       每次重新构建渲染树（render）的信息都会触发重绘或重排
       1. 浏览器界面变动如使用resize事件
       2. 删除/添加/更新dom元素
       3. 改变元素大小
       4. 通过display：none隐藏dom节点 - 触发重绘/重排
       5. 通过visibility：hidden隐藏一个dom元素 - 触发重绘
       6. 移动元素或者给页面中的dom元素添加动画
       7. 添加一个样式表，调整样式
      <h5>如何避免重绘或者重排</h5>
       1. 集中修改样式，不要一条一条的修改样式（集中渲染一次，不要修改一次渲染一次）
       2. 使用动画尽量使用fixed，absoulte，减少页面dom重排；
       3. 通过visibility：hidden隐藏一个dom元素 - 触发重绘
      <h5>说下进程、线程和协程</h5>
        进程：操作系统进行资源分配的一个独立单位
        线程：资源分配最小单位
        协程：基于线程之前，一个轻量级的线程；
      <h5></h5>
      <h5></h5>
      <h5></h5>
      <h5></h5>
    </pre>
  </div>
</template>